"""
Bloomberg utilities (pre-v3)

The following code is part based on work published by jfl on the Wilmott forum 
(thread "Python + Bloomberg FTW"). otherwise...

This file is part of FBox.

Copyright (c) 2014, Pedro A.C. Tavares
All rights reserved.

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along
with this program.  If not, see <http://www.gnu.org/licenses/>
"""


import win32com.client,pywintypes,pythoncom
import time,datetime,numpy,collections,pandas
from dateutil.relativedelta import relativedelta

#__PyTime_base__ = datetime.datetime(1899, 12, 30, 0, 0, 0)

def pytime_to_datetime(x):
    "Convert PyTime types as generated by win32com into standard Python datetime" 
    #return __PyTime_base__ + datetime.timedelta(days=float(oledt))
    return datetime.datetime(x.year,x.month,x.day,x.hour,x.minute,x.second)


def error_to_nan(x):
    "Convert Bloomberg errors (strings starting with #) to numpy.nan values)" 
    #return __PyTime_base__ + datetime.timedelta(days=float(oledt))
    if isinstance(x,basestring) and x[0] == "#":
        return numpy.nan
    else:
        return x


class broker:
    def __init__(self,raw_output=False,debug=0):
        self.blp = win32com.client.DispatchWithEvents("Bloomberg.Data.1", self.__event_handler__)
        self.blp.SubscriptionMode = win32com.client.constants.BySecurity
        self.blp.AutoRelease = False
        self.blp.ActivateRealtime = False

        self.blp.mymapper = {}
        self.blp.mytickcount = {}

        self.raw_output = raw_output
        self.debug = debug
       
        
    def session(self):
        return self.blp


    def subscribe(self,processor,securities, fields=None):
        if isinstance(securities,basestring): securities = [securities]

        if fields == None: fields = ["LAST_PRICE"]
        elif isinstance(fields,basestring): fields = [fields]

        #self.blp.myfieldnames = fields
        self.blp.ActivateRealtime = True
            
        self.blp.mytickcount.clear()
        self.blp.mymapper.clear()

        cookie = 1
        for s in securities:
            try:
                self.blp.mytickcount[cookie] = 0
                self.blp.mymapper[cookie] = processor
                self.blp.Subscribe(s, cookie, fields, Results = pythoncom.Empty)
                cookie += 1
                
                if self.debug > 1: print "BROKER DEBUG: Data request",cookie,s,fields
            
            except pywintypes.com_error:
                raise RuntimeError("COM error (may be caused by invalid field name): " + s + ", " + str(securities) + ", " + str(fields))
        
        self.blp.Flush()
        
        while True:
            pythoncom.PumpWaitingMessages()
        
        return True
    
        
    def data(self,securities, fields=None,timeout=None,pandas_format=True):
        if isinstance(securities,basestring): securities = [securities]

        if fields == None: fields = ["PX_LAST"]
        elif isinstance(fields,basestring): fields = [fields]

        if timeout == None: timeout = 5 + len(securities) * len(fields) / 2.
        
        #self.blp.myfieldnames = fields
        processor = self.event_processor(fields,False,self.raw_output,self.debug)
        self.blp.ActivateRealtime = False
            
        self.blp.mytickcount.clear()
        self.blp.mymapper.clear()

        cookie = 1
        for s in securities:
            try:
                self.blp.mytickcount[cookie] = 0
                self.blp.mymapper[cookie] = processor
                self.blp.Subscribe(s, cookie, fields, Results = pythoncom.Empty)
                cookie += 1
                
                if self.debug > 1: print "BROKER DEBUG: Data request",cookie,s,fields
            
            except pywintypes.com_error:
                raise RuntimeError("COM error (may be caused by invalid field name): " + s + ", " + str(securities) + ", " + str(fields))
        
        self.blp.Flush()
        
        self.__wait__(timeout)
        
        if pandas_format:
            return pandas.DataFrame(processor.output)
        else:
            return processor.output


    def history(self,securities, fields=None, from_date=None,to_date=None,intraday=False,timeout=None):
        if isinstance(securities,basestring): securities = [securities]

        if fields == None: fields = ["PX_LAST"]
        elif isinstance(fields,basestring): fields = [fields]

        if to_date == None: to_date = datetime.datetime.today()
        elif isinstance(to_date,basestring): to_date = datetime.strptime(to_date,"%Y%m%d")

        if from_date == None: from_date = to_date + relativedelta(years=-1)
        if isinstance(from_date,basestring): from_date = datetime.strptime(from_date,"%Y%m%d")

        if timeout == None: timeout = 10 + len(securities) * len(fields)
        
        #self.blp.myfieldnames = fields
        processor = self.event_processor(fields,True,self.raw_output,self.debug)
        self.blp.ActivateRealtime = False

        self.blp.mytickcount.clear()
        self.blp.mymapper.clear()

        cookie = 1
        for s in securities:
            self.blp.mytickcount[cookie] = 0
            self.blp.mymapper[cookie] = processor

            if self.debug > 1: print "BROKER DEBUG: History request",cookie,s,fields,from_date,to_date,intraday
            
            if intraday: self.blp.GetHistoricalData(s, cookie, fields, from_date, to_date, BarSize=1, Results=pythoncom.Empty)
            else:        self.blp.GetHistoricalData(s, cookie, fields, from_date, to_date, Results=pythoncom.Empty)
                 
            cookie += 1
        
        self.blp.Flush()

        if timeout == None: timeout = 10 + len(securities)
        self.__wait__(timeout)
        
        out = pandas.concat([x for x in processor.output.values()],axis=1)
        
        return out
        
        
    class __event_handler__:
        def OnData(self, security, cookie, fields, data, status):
            self.mytickcount[cookie] += 1
            processor = self.mymapper[cookie]
            processor.data(security,fields,data)

        def OnStatus(self,status,substatus,description):
            pass#processor.status(status,substatus,description)


    class event_processor:
        def __init__(self,fields,timeseries,raw_output,debug):
            self.status = []
            self.fields = fields
            self.timeseries = timeseries
            self.raw_output = raw_output
            self.debug = debug

            self.output = {}
       
        
        def __short_data__(self,data,size=50):
            d = str(data)
            if len(d) < size: return d
            else: return d[:size] + "..."

        
        def __reduce__(self,data):
            if isinstance(data,basestring):
                if data[0] == "#": data = numpy.nan
                
            elif isinstance(data,collections.Sequence):
                if len(data) == 1:
                    data = data[0]
                    data = self.__reduce__(data)
                else:
                    data = [self.__reduce__(x) for x in data]
        
            return data
        
        
        def __post_data__(self,data,security,fields):
            if not self.raw_output: data = [self.__reduce__(d) for d in data]
            return dict( zip(fields,data) )

                
        def __post_history__(self,data,security,fields):
            if not self.raw_output: data = self.__reduce__(data) # also converts list to tuple, otherwise DF ctor fails
            
            try:
                df = pandas.DataFrame(data,columns = ["Time"] + fields)
            
                df["Time"] = df["Time"].map(pytime_to_datetime)
                df = df.set_index("Time")
                
                df.columns = pandas.MultiIndex.from_tuples([(s,f) for f in fields for s in security])
                
                return df
            
            except:
                return pandas.DataFrame()
            
            
        def data(self,security,fields,data):
            if self.debug > 0: print "BROKER DEBUG: Data received:",security,fields,self.__short_data__(data)
            
            if self.timeseries:
                data = self.__post_history__(data,security,self.fields)
            else:
                data = self.__post_data__(data,security,self.fields)
                
            self.output[security[0]] = data
 
            
        def status(self,status,substatus,description):
            if self.debug > 0: print "BROKER DEBUG: Status received:",status,substatus,description
            self.status.append( {"status":status,"substatus":substatus,"description":description} )


    def __wait__(self,timeout):
        eot = timeout + time.time()
        done = False
        
        while not done:
            pythoncom.PumpWaitingMessages()
            if eot < time.time():
                done = True
                if self.debug > 0: print "BROKER DEBUG: TIMEOUT!"
            else:
                done = True
                for i in self.blp.mytickcount.keys():
                    if self.blp.mytickcount[i] == 0: done = False





if __name__ == "__main__":
    print "Start broker test\n"
    
    blp = broker(debug=1)
    securities = ["JPY Curncy", "USDGBP Curncy", "IBM US Equity"]
    
    print "\nStatic data"
    dat = blp.data(securities,["PX_LAST","VOLUME","EBITDA"])
    print type(dat)
    for s in securities: print s,dat[s]
    
    print "\nBulk data 1/2"
    dat = blp.data(["SX5E Index"],"INDX_MEMBERS")
    print type(dat),dat["SX5E Index"]["INDX_MEMBERS"]
    
    print "\nBulk data 1/2"
    dat = blp.data(["IBM US Equity"],"DVD_HIST",pandas_format=False)
    print type(dat),dat["IBM US Equity"]["DVD_HIST"]
    
    print "\nHistoric data"
    dat = blp.history(securities, ["PX_LAST","VOLUME","EBITDA"], datetime.date(2011,12,1), datetime.date(2012,2,1))
    print dat
    
    print "\nIntraday data"
    dat = blp.history("GBP Curncy","LAST_PRICE", datetime.datetime(2012,8,1,12,0,0), datetime.datetime(2012,8,1,12,0,2),intraday=True,timeout=30)
    print type(dat),dat["GBP Curncy"]
    
    print "\nSubscribe"
    class simple_processor:
        def data(self,security,fields,data):
            print "Data received:",security,fields,data
            
        def status(self,status,substatus,description):
            print "Status received:",status,substatus,description

    dat = blp.subscribe(simple_processor(),securities,["BID","ASK"])
    
    print "\nDone"